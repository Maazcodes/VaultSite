# Generated by Django 3.2.9 on 2022-03-09 21:36

from django.db import migrations


SQL = """
CREATE OR REPLACE FUNCTION _do_treenode_insert_file_accounting() RETURNS TRIGGER AS
$$
BEGIN
    UPDATE vault_treenode
    SET
        file_count = file_count + 1,
        size = COALESCE(size, 0) + COALESCE(NEW.size, 0)
    WHERE
        path @> (
            SELECT path
            FROM vault_treenode
            WHERE id = NEW.parent_id
        );

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _do_treenode_delete_file_accounting() RETURNS TRIGGER AS
$$
DECLARE
    size_delta int;
BEGIN
    IF OLD.node_type != 'FILE' THEN
        size_delta = 0;
    ELSE
        size_delta = COALESCE(OLD.size, 0);
    END IF;

    UPDATE vault_treenode
    SET
        file_count = file_count - 1,
        size = COALESCE(size, 0) - size_delta
    WHERE
        path @> OLD.path
    AND
        path != OLD.path;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _do_treenode_update_file_accounting() RETURNS TRIGGER AS
$$
DECLARE
    num_changed_attrs int = 0;
    file_count_delta int;
    size_delta int;
BEGIN
    IF pg_trigger_depth() > 1 THEN
        -- prevent trigger recursion
        RETURN NULL;
    END IF;

    -- assert that one and only one attribute of consequence to node file
    -- accounting changes in a given UPDATE
    IF OLD.deleted != NEW.deleted THEN
        num_changed_attrs = num_changed_attrs + 1;
    END IF;
    IF OLD.parent_id != NEW.parent_id THEN
        num_changed_attrs = num_changed_attrs + 1;
    END IF;
    IF OLD.size != NEW.size THEN
        num_changed_attrs = num_changed_attrs + 1;
    END IF;
    if num_changed_attrs > 1 THEN
        RAISE EXCEPTION 'At most one managed TreeNode attribute may change in a given UPDATE';
    END IF;

    IF OLD.deleted != NEW.deleted THEN
        -- case: soft un/delete
        IF NEW.deleted THEN
            size_delta = -1 * COALESCE(NEW.size, 0);
            file_count_delta = -1;
        ELSE
            size_delta = 1 * COALESCE(NEW.size, 0);
            file_count_delta = 1;
        END IF;

        -- Only propagate size changes to ancestors for FILE node deletions.
        -- This is necessary to avoid double-counting sizes which exist not
        -- only for FILE nodes, but for all non-FILE ancestors.
        if NEW.node_type != 'FILE' THEN
            size_delta = 0;
        END IF;

        UPDATE vault_treenode
        SET
            file_count = file_count + file_count_delta,
            size = COALESCE(size, 0) + size_delta
        WHERE
            path @> NEW.path
        AND
            path != NEW.path;

    ELSIF OLD.parent_id != NEW.parent_id THEN
        -- case: move

        IF NEW.node_type = 'FOLDER' THEN
            -- case: +1 for FOLDER nodes because parents' file_count includes
            -- folders because the behavior of
            -- _do_treenode_insert_file_accounting() increments ancestors'
            -- file_count on creation of all children, regardless of node_type
            file_count_delta = OLD.file_count + 1;
        ELSE
            file_count_delta = OLD.file_count;
        END IF;

        -- decrement old ancestors
        UPDATE vault_treenode AS self
        SET
            file_count = self.file_count - file_count_delta,
            size = COALESCE(self.size, 0) - COALESCE(OLD.size, 0)
        FROM
            vault_treenode as old_parent
        WHERE
            old_parent.id = OLD.parent_id
        AND
            self.path @> old_parent.path
        AND
            self.id != OLD.id;

        -- increment new ancestors
        UPDATE vault_treenode AS self
        SET
            file_count = self.file_count + file_count_delta,
            size = COALESCE(self.size, 0) + COALESCE(NEW.size, 0)
        FROM
            vault_treenode as new_parent
        WHERE
            new_parent.id = NEW.parent_id
        AND
            self.path @> new_parent.path
        AND
            self.id != NEW.id;

    ELSIF OLD.size != NEW.size THEN
        -- case: size change
        IF NEW.node_type != 'FILE' THEN
            RAISE EXCEPTION 'size of non-FILE nodes may not be explicitly modified';
        END IF;

        UPDATE vault_treenode
        SET
            size = COALESCE(size, 0) - COALESCE(OLD.size, 0) + COALESCE(NEW.size, 0)
        WHERE
            path @> NEW.path
        AND
            path != NEW.path;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION _do_treenode_set_new_file_count() RETURNS TRIGGER AS
$$
BEGIN
    NEW.file_count = 1;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER treenode_file_accounting_insert_trg
    AFTER INSERT ON vault_treenode
    FOR EACH ROW
    WHEN (NEW.node_type = 'FILE' OR NEW.node_type = 'FOLDER')
    EXECUTE PROCEDURE _do_treenode_insert_file_accounting();

CREATE TRIGGER treenode_file_accounting_update_trg
    AFTER UPDATE ON vault_treenode
    FOR EACH ROW
    WHEN (NEW.node_type = 'FILE' OR NEW.node_type = 'FOLDER')
    EXECUTE PROCEDURE _do_treenode_update_file_accounting();

CREATE TRIGGER treenode_file_accounting_delete_trg
    AFTER DELETE ON vault_treenode
    FOR EACH ROW
    WHEN (OLD.node_type = 'FILE' OR OLD.node_type = 'FOLDER')
    EXECUTE PROCEDURE _do_treenode_delete_file_accounting();

CREATE TRIGGER treenode_set_new_file_count
    BEFORE INSERT ON vault_treenode
    FOR EACH ROW
    WHEN (NEW.node_type = 'FILE')
    EXECUTE PROCEDURE _do_treenode_set_new_file_count();
"""


REVERSE_SQL = """
DROP TRIGGER IF EXISTS treenode_set_new_file_count ON vault_treenode;
DROP TRIGGER IF EXISTS treenode_file_accounting_delete_trg ON vault_treenode;
DROP TRIGGER IF EXISTS treenode_file_accounting_update_trg ON vault_treenode;
DROP TRIGGER IF EXISTS treenode_file_accounting_insert_trg ON vault_treenode;

DROP FUNCTION IF EXISTS _do_treenode_update_file_accounting();
DROP FUNCTION IF EXISTS _do_treenode_update_file_accounting();
DROP FUNCTION IF EXISTS _do_treenode_delete_file_accounting();
DROP FUNCTION IF EXISTS _do_treenode_insert_file_accounting();
"""


class Migration(migrations.Migration):

    dependencies = [
        ("vault", "0032_treenode_file_count"),
    ]

    operations = [
        migrations.RunSQL(
            sql=SQL,
            reverse_sql=REVERSE_SQL,
        ),
    ]
